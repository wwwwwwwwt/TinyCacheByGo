<!--
 * @Author: zzzzztw
 * @Date: 2023-05-02 14:29:18
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-05-05 12:18:36
 * @FilePath: /TinyCacheByGo/README.md
-->
# 基于Go的简易分布式缓存框架🚀

仿照Go 语言的groupcache，进行开发

### 主要特点
- 🔨:实现了基于LRU的缓存淘汰策略
- 📞:支持HTTP，rpc通信协议
- ⏰:使用锁机制和哈希表标记key的方法，防止缓存击穿
- 🎯:使用一致性哈希选择节点，实现负载均衡
- ☁ :使用protobuf和grpc来进行结点间的通信，二进制通信并http文本传输效率更快

#### 核心数据结构Group：负责与用户的交互，并且控制缓存值存储和获取的流程:

```
                    是
接收 key --> 检查是否被缓存 -----> 返回缓存值 ⑴
                |  否                         是
                |-----> 是否应当从远程节点获取 -----> 与远程节点交互 --> 返回缓存值 ⑵
                            |  否
                            |-----> 调用`回调函数`，获取值并添加到缓存 --> 返回缓存值 ⑶

```
GeeCache 的代码结构:

```
geecache/
    |--lru/
        |--lru.go  // lru 缓存淘汰策略
    |--byteview.go // 缓存值的抽象与封装
    |--cache.go    // 并发控制
    |--geecache.go // 负责与外部交互，控制缓存存储和获取的主流程


```


---
小知识点：
- 缓存雪崩：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的 key 设置了相同的过期时间等引起。
- 缓存击穿：一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时DB请求量大、压力骤增。
- 缓存穿透：查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB，导致宕机。

---

编译protobuf生成grpc,网上有些教程的编译语句已经过时了，注意辨别，实际生产中可以编写一份shell脚本来自动化编译

```shell
protoc -I. --go_out=. --go-grpc_out geecachepb/*.proto
```

